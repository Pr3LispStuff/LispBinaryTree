

(setf biba ‘(8 (4 (2 (1) (3)) (6 (5) (7))) (12 (10 (9) (11)) (14 (13) (15)))
                                            ))


(defun insertNode (Tree Val)
  (cond ((null Tree) (list Val nil nil))
        ((eql Val (car Tree)) (print "already exist") (car Tree))

        ((< Val (car Tree)) (append (list (car Tree)) (list (insertNode (cadr Tree) Val)) (list (caddr Tree))))
        (t (append (list (car Tree)) (list (cadr Tree)) (list (insertNode (caddr Tree) Val))))
  )
 )

;insert ne file und geht durch die chars ud macht nach jedem char einen Zeileumbruch
;dieser werden dann in tree, durch insert gespeichert. Dies ausgabe Zeigt nil für leere Referenz.
(defun insert (tree1 filename)
(defparameter tree '())
(* (with-open-file (stream filename)
    (do ((char (read stream nil)
               (read stream nil)))
        ((null char))
      (setf tree (insertNode tree char)))))
  (addAll tree1 tree)
)


;Hilfsfunktion die als erstes aufgerufen wird. Diese geht auf die Containes und gibt bei Containes == true den bearbeitetetn Baum zurück
;der in removeN aufgerufen wird
(defun removeN (Tree val)
  (cond
        ((equal 0 (containes Tree val)) Tree)
        (t (removeNode Tree val)
            )
      )
  )

  (defun removeNode (Tree val)
       (cond
              ;wenn Baum leer ist wird die Rekursion unterbrochen
             ((null Tree) nil)
             ;wenn im Knoten und gesuchter Wert übereinstimmen. Ist bis dahin schon durch den Baum gegangen und hat die Position des Löschvorgangs gefunden
             ((eql val (car Tree)) (cond
                                          ;
                                         ((and (null (cadr Tree)) (null (caddr Tree))) '())
                                         ((and (equal nil (cadr Tree)) (listp (caddr Tree))) (caddr Tree) (print "A"))
                                         ((and (listp (cadr Tree)) (equal nil (caddr Tree))) (cadr Tree) (print "B"))
                                         (t (append (getMin (caddr Tree)) (list (cadr Tree)) (append (list (removeNode (caddr Tree) (car (getMin (caddr Tree))))))))
                                   )
           )
             ;liste wird erstellt
             ((> val (car Tree)) (append (list (car Tree)) (list (cadr Tree)) (list (removeNode (caddr Tree) val))))
             ;linker Teilbaum
             ((< val (car Tree)) (append (list (car Tree)) (list (removeNode (cadr Tree) val)) (list (caddr Tree))))
         )
       )



;T bei true wird zurückgegeben
;0 bei false wenn nicht vorhanden
(defun containes (tree val)
  (cond
    ((null tree)  0)
    ((eql (car tree) val) t)
    (t  (cond
              ((listp (car tree)) (containes (append (car tree) (cdr tree)) val))
              ((containes (cdr tree) val))
        )
     )
   )
 )

  (defun size (tree)
    (cond
      ((null tree)  0)
      (t (+ (cond
              ((listp (car tree)) (size (append (car tree) (cdr tree))))
              ((+ 1 (size (cdr tree))))
             )
          )
       )
     )
    )

    (defun height (tree)
      (cond
        ((atom tree) 0)
        ((null tree) 0)
        (t
          (+ 1 (max (height (cadr tree)) (height (caddr tree))))
        )
       )
      )

    (defun getMax (Tree)
      (cond
        ((equal nil (caddr Tree)) Tree)
        (t (getMax (caddr Tree)))
      )
    )

    (defun getMin (Tree)
      (cond
        ((equal nil (cadr Tree)) Tree)
        (t (getMin (cadr Tree)))
      )
    )

    (defun isEmpty (tree)
      (cond ((null tree) T)
        (t nil)
      )
     )


    (defun levelOrder (tree)
        (loop while (not (null tree))
          do
          (setq node (car tree) tree (cdr tree))
          (if (not (null (car node)))(print (car node)))
          (setq tree (append tree (cdr node)))
        )
    )


  (defun addAll (tree otherTree)
      (print tree)
      (print otherTree)
      (cond ((null otherTree) tree)
            ((listp (car otherTree)) (append (addAll tree (car otherTree)))
            (t (append (list  (insert tree (car otherTree)))
                              (addAll tree (cdr otherTree))
               )
            )
      )
  )
