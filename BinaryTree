

(setf biba ‘(8 (4 (2 (1) (3)) (6 (5) (7))) (12 (10 (9) (11)) (14 (13) (15)))
                                            ))


(defun insert (Tree Val)
  (cond ((null Tree) (list Val nil nil))
        ((= Val (car Tree)) (print "already exist") Tree)

        ((< Val (car Tree))
          (list (car Tree) (insert (cadr Tree) Val) (caddr Tree)))

        (t (list (car Tree) (cadr Tree) (insert (caddr Tree) Val)))
  )
 )

;T bei true wird zurückgegeben
;0 bei false wenn nicht vorhanden
(defun containes (tree val)
  (cond
    ((null tree)  0)
    ((eql (car tree) val) t)
    (t  (cond
              ((listp (car tree)) (containes (append (car tree) (cdr tree)) val))
              ((containes (cdr tree) val))
        )
     )
   )
 )

;einfach die NestedList abgeschrieben...COPY AND PASTE GEEEEEEEHT
  (defun size (tree)
    (cond
      ((null tree)  0)
      (t (+ (cond
              ((listp (car tree)) (size (append (car tree) (cdr tree))))
              ((+ 1 (size (cdr tree))))
             )
          )
       )
     )
    )

    (defun height (tree)
      (cond
        ((atom tree) 0)
        ((null tree) 0)
        (t
          (+ 1 (max (height (cadr tree)) (height (caddr tree))))
        )
       )
      )

    (defun getMax (Tree)
      (cond
        ((equal nil (caddr Tree)) Tree)
        (t (getMax (caddr Tree)))
      )
    )

    (defun getMin (Tree)
      (cond
        ((equal nil (cadr Tree)) Tree)
        (t (getMin (cadr Tree)))
      )
    )
