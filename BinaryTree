

(setf biba ‘(8 (4 (2 (1) (3)) (6 (5) (7))) (12 (10 (9) (11)) (14 (13) (15)))
                                            ))


(defun insert (Tree Val)
  (cond ((null Tree) (list Val nil nil))
        ((eql Val (car Tree)) (print "already exist") Tree)

        ((< Val (car Tree))
          (list (car Tree) (insert (cadr Tree) Val) (caddr Tree)))

        (t (list (car Tree) (cadr Tree) (insert (caddr Tree) Val)))
  )
 )




(defun removeNode (Tree val)
  (print Tree)
  (print (cadr Tree))
  (print (caddr Tree))
  (cond
        ((null Tree) nil)
        ((equal 0 (containes Tree val)) (print "nope") (getMin (caddr Tree)))
        ((eql val (car Tree)) (cond
                                    ((and (null (cadr Tree)) (null (caddr Tree))) '())
                                    ((and (equal nil (cadr Tree)) (listp (caddr Tree))) (caddr Tree) (print "A"))
                                    ((and (listp (cadr Tree)) (equal nil (caddr Tree))) (cadr Tree) (print "B"))
                                    (t (append (getMin (caddr Tree)) (list (cadr Tree)) (append (list (removeNode (caddr Tree) (list (getMin (caddr Tree))))))     ))

                              )
      )
        ;rechter Teilbaum
        ((> val (car Tree)) (append (list (car Tree)) (list (cadr Tree)) (list (removeNode (caddr Tree) val))))
        ;linker Teilbaum
        (t (append (list (car Tree)) (list (removeNode (cadr Tree) val)) (list (caddr Tree))))
    )
  )


;T bei true wird zurückgegeben
;0 bei false wenn nicht vorhanden
(defun containes (tree val)
  (cond
    ((null tree)  0)
    ((eql (car tree) val) t)
    (t  (cond
              ((listp (car tree)) (containes (append (car tree) (cdr tree)) val))
              ((containes (cdr tree) val))
        )
     )
   )
 )

;einfach die NestedList abgeschrieben...COPY AND PASTE GEEEEEEEHT
  (defun size (tree)
    (cond
      ((null tree)  0)
      (t (+ (cond
              ((listp (car tree)) (size (append (car tree) (cdr tree))))
              ((+ 1 (size (cdr tree))))
             )
          )
       )
     )
    )

    (defun height (tree)
      (cond
        ((atom tree) 0)
        ((null tree) 0)
        (t
          (+ 1 (max (height (cadr tree)) (height (caddr tree))))
        )
       )
      )

    (defun getMax (Tree)
      (cond
        ((equal nil (caddr Tree)) Tree)
        (t (getMax (caddr Tree)))
      )
    )

    (defun getMin (Tree)
      (cond
        ((equal nil (cadr Tree)) Tree)
        (t (getMin (cadr Tree)))
      )
    )

    (defun isEmpty (tree)
      (cond ((null tree) T)
        (t nil)
      )
     )
          
    (defun printlevelorder (tree)
      (levelorder (list tree))
    )
    
    (defun levelOrder (tree)
        (loop while (not (null tree))
          do
          (setq node (car tree) tree (cdr tree))
          (if (not (null (car node)))(print (car node)))
          (setq tree (append tree (cdr node)))
        )
    )
    
    
        (defun addAll (tree otherTree)
      (cond ((null otherTree) tree)
        (t
          (cond ((listp (car otherTree))
            (print "hallo1")
            (addAll tree (cdr otherTree)))
            
              (t 
                (append tree (insert tree (car otherTree)))
                (print "hallo2")
                (addAll tree (cdr otherTree)
              ))
          )
        )
      )
    )
